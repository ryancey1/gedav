---
title: "Homework 2"
author: "Ryan Yancey"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
    html_document:
        highlight: tango
        theme: cosmo
        keep_md: yes
colorlinks: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  fig.align = "center",
  fig.width = 9,
  fig.height = 8
)

# clear out the environment
rm(list = ls())
```

------------------------------------------------------------------------

#### For this assignment, we will be evaluating different normalization methods on 2-channel arrays in which 4 biological samples were run. The study is from GEO and the description of the experiment is provided as follows.

> **Series GSE12050**: Subcutaneous adipose tissue from lean and obese subjects ([source][1]).

#### Obtaining adipose tissue samples are paramount to the understanding of human obesity. We have examined the impact of needle-aspirated and surgical biopsy techniques on the study of subcutaneous adipose tissue (scAT) gene expression in both obese and lean subjects. Biopsy sampling methods have a significant impact on data interpretation and revealed that gene expression profiles derived from surgical tissue biopsies better capture the significant changes in molecular pathways associated with obesity. We hypothesize that this is because needle biopsies do not aspirate the fibrotic fraction of scAT; which subsequently results in an under-representation of the inflammatory and metabolic changes that coincide with obesity. This analysis revealed that the biopsy technique influences the gene expression underlying the biological themes commonly discussed in obesity (e.g. inflammation, extracellular matrix, metabolism, etc), and is therefore a caveat to consider when designing microarray experiments. These results have crucial implications for the clinical and physiopathological understanding of human obesity and therapeutic approaches. We will be working with 4 lean subjects from which a needle biopsy was taken.

------------------------------------------------------------------------

#### **1.) First load the marray library, then load the 4 GenePix files, making sure to extract the foreground and background median values from the Cy5 and Cy3 channels.**

```{r load-marray}
suppressPackageStartupMessages(library(marray))
```

First we need to decompress the `GSE12050_amend.zip` dataset downloaded into the "data" directory.

```{r unzip-and-load}
dir(path = "data")

# unzip and gunzip the GSE files
system(command = "unzip -o data/GSE12050_amend.zip -d data/gp; gunzip -q data/gp/*")

# load data
data <- read.GenePix(path = "data/gp")
```

#### **2.) Normalize each array using median global, loess, and print-tip-group loess methods. Then plot MvA plots of all 4 arrays comparing no normalization to the other 3 normalization approaches.**

```{r norm-function, cache=TRUE}
# define function to reduce redundancy
norm_and_plot <- function(array, plot = TRUE) {
    # named list of normalized data
    norms <- list(
        NotNormalized = maNorm(array, norm = "n"),
        MedianNormalized = maNorm(array, norm = "m"),
        LoessNormalized = maNorm(array, norm = "l"),
        PrintTipLoessNormalized = maNorm(array, norm = "p")
    )
    if (plot) {
        # graph normalized data
        par(mfrow = c(2, 2), lwd = 2)
        for (i in seq_along(norms)) {
            d.method <- names(norms)[i]
            d.name <- deparse(substitute(array))
            maPlot(
                m = norms[[i]],
                lines.func = NULL,
                legend.func = NULL,
                main = paste(d.name, d.method, sep = ": ")
            )
        }
    }
    else {
        return(norms)
    }
}

# run function on all arrays
norm_and_plot(data[, 1])
norm_and_plot(data[, 2])
norm_and_plot(data[, 3])
norm_and_plot(data[, 4])
```

#### **3.) Plot density plots of the log ratio values for each normalization (and pre normalization) for only array #4. Put them all on the same plot. Make sure to label the axes and provide a legend.**

```{r density-plots, cache = TRUE}
# save array4 normalized to variable
array4 <- norm_and_plot(data[, 4], plot = FALSE)

# save density calculations
d1 <- density(maM(array4[[1]]), na.rm = TRUE) # none
d2 <- density(maM(array4[[2]]), na.rm = TRUE) # median
d3 <- density(maM(array4[[3]]), na.rm = TRUE) # loess
d4 <- density(maM(array4[[4]]), na.rm = TRUE) # printiploess

# plot ranges
par(lwd = 3, font.lab = 2)
plot(
    x = range(d1$x, d2$x, d3$x, d4$x),
    y = range(d1$y, d2$y, d3$y, d4$y),
    type = "n",
    ylab = "Density",
    xlab = "Log-ratios",
    main = "Density plot"
)
# density plots
lines(d1, col = "magenta")
lines(d2, col = "cyan")
lines(d3, col = "red")
lines(d4, col = "green", lty = 3) # dotted overlapped easier to see
legend(
    "topright",
    legend = labels(array4),
    lty = c(1, 1, 1, 3), 
    col = c("magenta", "cyan", "red", "green"),
    inset = 0.02, cex = 0.7, text.font = 2
)
text(
  x = 2.5, y = 0.5, adj = c(0, 1), cex = 0.8,
  labels = "<- Loess/PrintTipLoess\n    overlap tremendously",
  font = 2
)
```

#### **4.) Based on the plots generated so far, which normalization do you think is most preferred for this dataset?**

For this data set, it appears either the "within-print-tip-group intensity dependent location normalization" (printTipLoess) or the "global intensity or A-dependent location normalization" (loess) methods work *equally* well.

#### **5.) Research has demonstrated that often a single channel, background subtracted provides as good a normalization as using both channels. To test this, we will be utilizing the fact that these 4 samples are replicates and calculate the correlation between them. So, first extract the Cy5 foreground and background values for each of the 4 arrays and subtract the background from the foreground values, then log2 transform these values. Then calculate global median normalization on these 4 arrays using these background subtracted Cy5 values. Hint, you need to use the median of each array to scale, such that after normalization, all arrays will have a median of 1.**

```{r red-channel-normalization, warning=FALSE}
Rf <- maRf(data) # Cy5 fg
Rb <- maRb(data) # Cy5 bg
R <- Rf - Rb # subtract bg from fg

# log2 transform
log2R <- log2(R)

# calculate c = log2(k)
c <- apply(log2R, 2, median, na.rm = TRUE)

# subtract the vector from each row
mnorm.log2R <- t(apply(log2R, 1, function(x) x - c))

# verify the median is log2(1) = 0
apply(mnorm.log2R, 2, median, na.rm = TRUE)
```


#### **6.) Next calculate a Spearman’s rank correlation between all 4 arrays that you normalized in #5 and do the same with the M values from loess normalized data that you generated in #2. Plot a scatter plot matrix for each of the two normalizations (pairs() function), and be sure to label the arrays and title the plot. Print the correlation coefficients to the screen.**

```{r correlation}
(corr.mnorm <- round(cor(mnorm.log2R,
                   use = "pairwise.complete.obs",
                   method = "spearman"), 2))
pairs(
  x = corr.mnorm,
  las = 2, pch = 19, cex.labels = 0.9,
  labels = gsub(pattern = ".*/", replacement = "", colnames(corr.mnorm)),
  upper.panel = NULL,
  col = "green",
  main = "Single Channel, Global Median Normalized"
)

(corr.loess <- round(cor(maM(maNorm(data, norm = "loess")),
                   use = "pairwise.complete.obs",
                   method = "spearman"), 2))
pairs(
  x = corr.loess,
  las = 2, pch = 19, cex.labels = 0.9,
  labels = gsub(pattern = ".*/", replacement = "", colnames(corr.loess)),
  upper.panel = NULL,
  col = "red",
  main = "Two Channel, Loess Normalized"
)
```

#### **7.) Now we want to compare these normalizations to quantile normalized data to see if we gain anything by leveraging the distributions across all 4 arrays. Carry out the steps in the lecture or use the paper from Bolstad et al. entitled: “A comparison of normalization methods for high density oligonucleotide array data based on variance and bias” (on the course website), but we are only going to conduct this on the Cy5 channel. The basic steps are as follows (these 6 steps are calculated on non-logged data; the data is logged after these steps are carried out):**

1. Subtract the foreground – background for each of the 4 chips for only the Cy5 channel. This should all be on the linear or raw scale (no logging yet).

2. Sort each column independently in this new matrix

3. Calculate row means for the sorted matrix

4. Create a new matrix with each row having the same values as the sorted row mean vectors from step #3 (you should have a new R matrix)

5. Rank the columns independently on the original background subtracted matrix (from step #1) Hint: use the `rank()` function with the argument `ties=”first”` or `order()`

6. Reorder the columns in the new matrix from step #4 using the ranks from step #5

**To verify that each array has the same distribution, use the `hist()` function to look at various arrays (e.g., `hist(c5.norm[,1])`; `hist(c5.norm[,2])`; etc.). Slight differences in distributions are a result of the ties in the ranking.**

#### **8.) Now log (base 2) the new R matrix you created from step 6 (question #7) and calculate a Spearman’s rank correlation between the 4 arrays and plot a scatter plot matrix as you did before. Print the correlation coefficients to the screen.**

#### **9.) Of the 4 normalization methods, which do you suggest as optimal and why?**

#### **10.) Now we want to work with a qRT-PCR dataset from patients with an inflammatory disease. The genes measured for this experiment included a set of proinflammatory chemokines and cytokines that are related to the disease. Download the raw qRT-PCR file called Inflammation_qRT-PCR.csv. Then change the normalization script from the lecture notes to include the housekeeping genes beta actin, GAPDH, and 18S. Look at the file to make sure the housekeepers are spelled correctly. Run the normalization script and output a data matrix of fold change values.**

```{r qRT-PCR}
source("scripts/f.parse.R")

pa <- "data/"
fi <- "qRT-PCR.csv"
out.fi <- "out.fi"

f.parse(pa, fi, out.fi)
```


#### **11.) Read the normalized qRT-PCR data matrix into R, using a Spearman’s rank correlation, which two patients are most correlated? Plot these two patients against each other in a scatter plot.**

```{r final-chunk}

norm.dat <- read.table("data/out.fi", header = TRUE, row.names = 1, sep = "\t")

(corr.norm.dat <- cor(t(norm.dat), method = "spearman"))
```

[1]: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE12050

